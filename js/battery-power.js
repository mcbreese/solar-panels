// Followed class diagram and top down and activity
// Set all the variables which will be fulfilled by database or user input fields
var area=10; // metre squared
var elevationAngle=25; // Degrees
var sunAngle=[0,0,0,0,2,9,18,27,37,46,54,60,62,60,54,46,37,27,18,9,2,0,0,0];// Degrees, there will need to be an array for Winter
var efficiency = 0.15
var batteryEfficiency=0.85; // %
var pdmEfficiency=0.90;
var battCap=250; // Amp hours
var battVoltage=12; // Volts
var consumption=300; //Watts
var efficiency=0.2;
var power= 1000;
var area=10;
var elevationAngle=25;
var watts=300;

// Elevation angles
function angleOfSun(sunAngle){
  // If 0 do nothing as below horizon, else add the roof angle to the sun
  for(let x=0; x<sunAngle.length; x++){
    if (sunAngle[x]==0){
      // Do nothing
    }
    else {
      // 25 is the roof angle
      sunAngle[x]+=elevationAngle;
    }
  }
  console.log(sunAngle);
}

// Total Power Output of the BCM
function generateBCMOutput(solarEfficiency, power
, area, batteryEfficiency, elevationAngle){
// PBCM = C × PSun × A × BCMeff × sin(ESunRoof)
// Same values as before + BCMeff
// Will need to carry them over?
elevationAngle= (Math.PI / 180) * elevationAngle;
let bcmOutput= solarEfficiency*power*area*batteryEfficiency*Math.sin(elevationAngle);
/*
console.log("The Battery Charge Module (BCM) that manages the power generated by the solar panel is outputting = " + bcmOutput + " Watts");
*/
return bcmOutput;
};

// Power Distribuion Efficiency is 0.9, the watts is 300
// PDM disitributes power to the house
function generateBaseLoad(watts, pdmEfficiency){
watts+=30; // Add 30W for the equipment - describe on webpage
let baseLoad=watts + ((1 - pdmEfficiency) * watts);
// Watts always 330 then
// The lower efficiency of the PDM increases the base load
return baseLoad;
};

// This function shows what the battery charge module is currently outputting minus the base load of the house, whats left is the power balance and will go into the battery?
function generatePowerBalance(bcmOutput, baseLoad){
  let powerBalance=bcmOutput-baseLoad;
  return powerBalance;
};

function instantaneousChargeDischarge(powerBalance, battVoltage){
let charge=powerBalance/battVoltage;
return charge;

};

function generateStateOfCharge(battCap, charge){
// Now I need to iterate
// Batt charge of previous time step (begin at max which is 250A) + iCharge of current time step
// Initial battery charge = 
//console.log("Battery capacity is " + battCap);
  if(battCap+charge <= 0){
    return 0;
  } 
  if (battCap+charge >= 250){
    return 250;
  } else {
    return battCap+charge;
  }
};

function twentyFourHoursCharge(battCap, battVoltage){
 let totalCap=battCap;
 for(i=0; i<24; i++){
   // Generate the power balance which requires BCM Output and the base load
  let powerBalance=generatePowerBalance(
  generateBCMOutput(efficiency, power, area, batteryEfficiency, sunAngle[i]),
  generateBaseLoad(watts, pdmEfficiency));
  //console.log("The BCM and PDM balance atm is " + powerBalance);
    // Then generate the charge with that power balance which is in Amps
  let charge=instantaneousChargeDischarge(powerBalance, battVoltage);
  //console.log("The battery charge is currently " + charge + " A");
  //console.log("The charge of the battery is = " + charge);
  // Use the charge to determine the battery charge in Amp Hours
  let battCharge=generateStateOfCharge(battCap,charge);
  //console.log("In amp hours the battery charge is " + battCharge);
  battCap=battCharge;
  let discharge=generateSummerWinterDepth(battCharge,totalCap);
  
  console.log("At " + i + " the battery discharge is " + discharge+ " %");
  

 } 
}

function generateSummerWinterDepth(battCharge,totalCap){
  // ???
  let discharge=(1-(battCharge/totalCap)) * 100;
  return discharge;
};

// Update the elevation angles of the house + the sun on horizon array
angleOfSun(sunAngle);

// Determine the battery charge over 24 hours
// Input 250 and 12 in this test
twentyFourHoursCharge(battCap, battVoltage);